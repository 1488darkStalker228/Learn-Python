# Импортировали класс Purse из другого файла;
from Lesson_1 import Purse

# С помощью наследования можно писать грамотно структурированный код, при помощи фреймворков и разнообразных
# библиотек; Наследование позволяет нам дополнять и расширять функционал заранее созданных классов, не переписывая не
# дублирую уже написанный код; При наследовании, класс потомок имеет все свойства и методы класса родителя; В классе
# наследнике можно переопределять методы родительского класса - это полиморфизм;

class PurseExtended(Purse):
    # Также можно переопределять метод-конструктор __init__;
    def __init__(self, currency, name, something):
        # Вызываем конструктор родительского класса, прокидываем туда reqired аргументы, и теперь во вновь созданных
        # объектах дочернего класса, будут атрибуты из родительского конструктора; Данная запись называется "Простое
        # наследование", она неактуальна; Purse.__init__(self, currency, name)

        # Метод super, осуществляет поиск методов в родительских классах. Используем именно такой синтаксис;
        super().__init__(currency, name)

        # Далее, можем писать собственный код;
        self.something = something
        # Обращаемся к переменной, лежащей в конструкторе родительского класса;
        self.smt = 400

    # Создание одноимённого метода нужно для добавления функциональности, либо для полного переопределения;
    def polymorph_method(self):
        # Написали какой-то код;
        print('Это метод класса-потомка')
        # Вызвали метод родительского класса
        super().polymorph_method()

# a = PurseExtended('ETH', 'Constantin', 'suck_some_dick')
# a.polymorph_method()
# print(a.name)
# print(a.something)
# print(a.smt)


# Под термином полиморфизм стоит понимать "Если вы видите метод 'a', то не надо думать, что он делает тоже самое,
# что метод 'a' в другом классе;
class A:
    def a(self):
        print('A')

class B:
    def a(self):
        print('B')

class C(B):
    def a(self):
        print('C')

class D(C, A):
    def a(self):
        # В данном случае, отработал метод класса C, потому что метод super нашёл нужный метод в классе C и завершил
        # работу. Поиск методов при помощи super(), называется линеаризация;
        super().a()
        # При помощи данной записи, можно увидеть, порядок просмотра классов для поиска методов;
        print(self.__class__.__mro__)

        # Если приходится применять такую запись, значит с кодом что-то не так. Применяем данный метод вкупе с
        # просмотром линии линеаризации;
        super(B, self).a()
# Альтернативная запись для показа порядка просмотра классов;
print(D.__mro__)

D().a()
